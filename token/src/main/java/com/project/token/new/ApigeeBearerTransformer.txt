package com.project.token.transformer;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import jakarta.validation.constraints.NotNull;
import org.apache.hc.core5.ssl.SSLContexts;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import software.amazon.awssdk.http.HttpStatusCode;
import software.amazon.lambda.powertools.parameters.transform.Transformer;

import javax.net.ssl.SSLContext;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Base64;

/**
 * Powertools v2 Transformer for OAuth2 Bearer Token.
 * <p>
 * Migrated from Powertools v1 BasicTransformer to v2 Transformer interface.
 * <p>
 * Key changes:
 * - extends BasicTransformer → implements Transformer<String>
 * - applyTransformation() → transform()
 * - TransformationException → RuntimeException
 * <p>
 * This transformer:
 * 1. Parses OAuth2 credentials from Secrets Manager
 * 2. Calls OAuth2 token endpoint with client credentials
 * 3. Returns the bearer token (access_token)
 * <p>
 * Environment Variables:
 * - TOKEN_ENDPOINT_URL: OAuth2 token endpoint URL (required)
 * - OAUTH2_TIMEOUT_SECONDS: Optional timeout in seconds (default: 10)
 */
public class ApigeeBearerTransformer implements Transformer<String> {

    private static final Logger log =
            LogManager.getFormatterLogger(ApigeeBearerTransformer.class);

    private static final String TRUST_STORE_LOCATION = "/tmp/trustStore.jks";
    private static final String TOKEN_ENDPOINT_URL = getRequiredEnv("TOKEN_ENDPOINT_URL");

    private final HttpClient httpClient;
    private final HttpRequest.Builder requestBuilder;
    private final ObjectMapper mapper;
    private final URI tokenEndpointUrl;

    private static String getRequiredEnv(String key) {
        String value = System.getenv(key);
        if (value == null || value.trim().isEmpty()) {
            throw new IllegalArgumentException("Required environment variable '" + key + "' is not set");
        }
        return value;
    }

    public ApigeeBearerTransformer() {
        this.tokenEndpointUrl = URI.create(TOKEN_ENDPOINT_URL);

        SSLContext sslContext = null;

        try {
            KeyStore ks = KeyStore.getInstance("JKS");

            String filename = System.getProperty("java.home")
                    + "/lib/security/cacerts".replace('/', File.separatorChar);

            try (InputStream fis = this.getClass().getResourceAsStream(filename);
                 InputStream inputStream =
                         this.getClass().getResourceAsStream("/svb_root_ssl_cert.pem");
                 FileOutputStream fos =
                         new FileOutputStream(TRUST_STORE_LOCATION)) {

                ks.load(fis, "".toCharArray());

                ks.setCertificateEntry(
                        "svbRoot",
                        CertificateFactory.getInstance("X.509")
                                .generateCertificate(inputStream)
                );

                ks.store(fos, "".toCharArray());

                System.setProperty("javax.net.ssl.trustStore", TRUST_STORE_LOCATION);
                System.setProperty("javax.net.ssl.trustStorePassword", "");
            }
        } catch (IOException | CertificateException | NoSuchAlgorithmException e) {
            log.error("Unable to create the keystore with provided certificate.", e);
            throw new RuntimeException(e);
        } catch (KeyStoreException e) {
            log.error("Unable to create keystore instance.", e);
            throw new RuntimeException(e);
        }

        try {
            sslContext = SSLContexts.custom()
                    .setProtocol("TLSv1.2")
                    .loadTrustMaterial(null, (X509Certificate[] chain, String authType) -> true)
                    .build();
        } catch (KeyStoreException | NoSuchAlgorithmException | KeyManagementException e) {
            log.error("Unable to create SSL Context.", e);
            throw new RuntimeException(e);
        }

        // Fallback to default SSL context if custom one failed
        if (sslContext == null) {
            log.error("Context is null, using default.");
            try {
                sslContext = SSLContext.getDefault();
            } catch (NoSuchAlgorithmException e) {
                throw new RuntimeException(e);
            }
        }

        this.httpClient = HttpClient.newBuilder()
                .sslContext(sslContext)
                .build();

        this.requestBuilder = HttpRequest.newBuilder()
                .uri(this.tokenEndpointUrl)
                .version(HttpClient.Version.HTTP_2)
                .headers("Content-Type", "application/x-www-form-urlencoded")
                .POST(HttpRequest.BodyPublishers.ofString(
                        "grant_type=client_credentials"))
                .timeout(Duration.of(getTimeoutValue(), ChronoUnit.SECONDS));

        this.mapper = new ObjectMapper();
        this.mapper.registerModule(new JavaTimeModule());

        log.info("ApigeeBearerTransformer initialized with endpoint: %s", this.tokenEndpointUrl);
    }

    /**
     * Apply transformation - required by Transformer interface in Powertools v2.
     * <p>
     * This method:
     * 1. Parses Apigee credentials from the secret value
     * 2. Makes HTTP call to Apigee OAuth endpoint
     * 3. Returns the bearer token
     *
     * @param value JSON string containing username and password
     * @param targetClass The target class to cast the result to (String.class)
     * @return Bearer token (access_token)
     */
    @Override
    public String applyTransformation(String value, Class<String> targetClass) {
        ApigeeAuthToken token;

        try {
            token = mapper.readValue(value, ApigeeAuthToken.class);
        } catch (Exception e) {
            log.error("Unable to parse value from secret.", e);
            throw new RuntimeException("Failed to parse Apigee credentials", e);
        }

        try {
            HttpResponse<String> response = this.httpClient.send(
                    this.requestBuilder
                            .header("Authorization", getBasicAuthorization(token))
                            .build(),
                    HttpResponse.BodyHandlers.ofString()
            );

            if (HttpStatusCode.OK == response.statusCode()) {
                log.info("Successfully retrieved bearer token from %s",
                        this.tokenEndpointUrl.toString());
                return mapper.readValue(
                        response.body(),
                        ApigeeOauthResponse.class
                ).accessToken();
            } else {
                log.error("Invalid response (%s) from OAuth2 endpoint",
                        response.statusCode());
                throw new RuntimeException(
                        "Error received from OAuth2 endpoint. Response is " + response.body());
            }
        } catch (IOException | InterruptedException e) {
            log.error("Unable to call %s to retrieve bearer token.",
                    this.tokenEndpointUrl.toString(), e);
            throw new RuntimeException("Exception while attempting to call OAuth2 endpoint", e);
        }
    }

    private String getBasicAuthorization(ApigeeAuthToken token) {
        return "Basic " + Base64.getEncoder().encodeToString(
                (token.userName() + ":" + token.password()).getBytes()
        );
    }

    private Integer getTimeoutValue() {
        try {
            return Integer.parseInt(System.getenv("OAUTH2_TIMEOUT_SECONDS"));
        } catch (Exception e) {
            log.trace("Default to 10 second OAuth2 timeout.");
            return 10;
        }
    }

    record ApigeeAuthToken(
            @JsonProperty(value = "username", required = true)
            @NotNull String userName,
            @JsonProperty(value = "password", required = true)
            @NotNull String password
    ) implements Serializable {
    }

    record ApigeeOauthResponse(
            @JsonProperty("token_type") String tokenType,
            @JsonProperty("issued_at") Instant issuedAt,
            @JsonProperty("access_token") String accessToken,
            @JsonProperty("expires_in") Long expiresIn
    ) implements Serializable {
    }
}

