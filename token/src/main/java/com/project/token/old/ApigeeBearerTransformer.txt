package com.svb.payments.secretsmanager;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import jakarta.validation.constraints.NotNull;
import org.apache.hc.core5.ssl.SSLContexts;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import software.amazon.awssdk.http.HttpStatusCode;
import software.amazon.lambda.powertools.parameters.exception.TransformationException;
import software.amazon.lambda.powertools.parameters.transform.BasicTransformer;

import javax.net.ssl.SSLContext;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Base64;
import java.util.Map;
import java.util.Optional;

public class ApigeeBearerTransformer extends BasicTransformer {

    private static final Logger log =
            LogManager.getFormatterLogger(ApigeeBearerTransformer.class);

    private static final String TRUST_STORE_LOCATION = "/tmp/trustStore.jks";

    private final HttpClient httpClient;
    private final HttpRequest.Builder requestBuilder;
    private final ObjectMapper mapper;
    private final URI apigeeUrl;

    private static final Map<String, String> oathEndpoints = Map.of(
            "dev", "https://internal.dev.api.svb.com/v1/security/oauth/token",
            "qa", "https://internal.qa.api.svb.com/v1/security/oauth/token",
            "preprod", "https://internal.uat.api.svb.com/v1/security/oauth/token",
            "prod", "https://internal.api.svb.com/v1/security/oauth/token"
    );

    public ApigeeBearerTransformer() {
        this(System.getenv("env"));
    }

    public ApigeeBearerTransformer(String environment) {
        this.apigeeUrl = Optional.ofNullable(environment)
                .filter(oathEndpoints::containsKey)
                .map(oathEndpoints::get)
                .map(URI::create)
                .orElseThrow(() ->
                        new IllegalArgumentException("env is a required environment variable"));

        SSLContext sslContext = null;

        try {
            KeyStore ks = KeyStore.getInstance("JKS");

            String filename = System.getProperty("java.home")
                    + "/lib/security/cacerts".replace('/', File.separatorChar);

            try (InputStream fis = this.getClass().getResourceAsStream(filename);
                 InputStream inputStream =
                         this.getClass().getResourceAsStream("/svb_root_ssl_cert.pem");
                 FileOutputStream fos =
                         new FileOutputStream(TRUST_STORE_LOCATION)) {

                ks.load(fis, "".toCharArray());

                ks.setCertificateEntry(
                        "svbRoot",
                        CertificateFactory.getInstance("X.509")
                                .generateCertificate(inputStream)
                );

                ks.store(fos, "".toCharArray());

                System.setProperty("javax.net.ssl.trustStore", TRUST_STORE_LOCATION);
                System.setProperty("javax.net.ssl.trustStorePassword", "");
            }
        } catch (IOException | CertificateException | NoSuchAlgorithmException e) {
            log.error("Unable to create the keystore with provided certificate.", e);
            throw new RuntimeException(e);
        }

        try {
            sslContext = SSLContexts.custom()
                    .setProtocol("TLSv1.2")
                    .loadTrustMaterial(null, (X509Certificate[] chain, String authType) -> true)
                    .build();
        } catch (KeyStoreException | NoSuchAlgorithmException |
                 KeyManagementException | UnrecoverableKeyException e) {
            log.error("Unable to create SSL Context.", e);
            throw new RuntimeException(e);
        }

        if (sslContext == null) {
            log.error("Context is null, using default.");
            try {
                sslContext = SSLContext.getDefault();
            } catch (NoSuchAlgorithmException e) {
                throw new RuntimeException(e);
            }
        }

        this.httpClient = HttpClient.newBuilder()
                .sslContext(sslContext)
                .build();

        this.requestBuilder = HttpRequest.newBuilder()
                .uri(this.apigeeUrl)
                .version(HttpClient.Version.HTTP_2)
                .headers("Content-Type", "application/x-www-form-urlencoded")
                .POST(HttpRequest.BodyPublishers.ofString(
                        "grant_type=client_credentials"))
                .timeout(Duration.of(getTimeoutValue(), ChronoUnit.SECONDS));

        this.mapper = new ObjectMapper();
        this.mapper.registerModule(new JavaTimeModule());
    }

    @Override
    public String applyTransformation(String value) {
        ApigeeAuthToken token;

        try {
            token = mapper.readValue(value, ApigeeAuthToken.class);
        } catch (Exception e) {
            log.error("Unable to parse value [{}] from secret.", value, e);
            throw new TransformationException(e);
        }

        try {
            HttpResponse<String> response = this.httpClient.send(
                    this.requestBuilder
                            .header("Authorization", getBasicAuthorization(token))
                            .build(),
                    HttpResponse.BodyHandlers.ofString()
            );

            if (HttpStatusCode.OK == response.statusCode()) {
                log.info("Successfully retrieved bearer token from %s",
                        this.apigeeUrl.toString());
                return mapper.readValue(
                        response.body(),
                        ApigeeOauthResponse.class
                ).accessToken();
            } else {
                log.error("Invalid response ({}) from Apigee",
                        response.statusCode());
                throw new RuntimeException(
                        "Error received from Apigee. Response is " + response.body());
            }
        } catch (IOException | InterruptedException e) {
            log.error("Unable to call %s to retrieve bearer token.",
                    this.apigeeUrl.toString(), e);
            throw new RuntimeException("Exception while attempting to call Apigee", e);
        }
    }

    private String getBasicAuthorization(ApigeeAuthToken token) {
        return "Basic " + Base64.getEncoder().encodeToString(
                (token.userName() + ":" + token.password()).getBytes()
        );
    }

    private Integer getTimeoutValue() {
        try {
            return Integer.parseInt(System.getenv("APIGEE_OATH_TIMEOUT"));
        } catch (Exception e) {
            log.trace("Default to 2 second Apigee timeout.");
            return 2;
        }
    }

    record ApigeeAuthToken(
            @JsonProperty(value = "username", required = true)
            @NotNull String userName,
            @JsonProperty(value = "password", required = true)
            @NotNull String password
    ) implements Serializable {
    }

    record ApigeeOauthResponse(
            @JsonProperty("token_type") String tokenType,
            @JsonProperty("issued_at") Instant issuedAt,
            @JsonProperty("access_token") String accessToken,
            @JsonProperty("expires_in") Long expiresIn
    ) implements Serializable {
    }
}
